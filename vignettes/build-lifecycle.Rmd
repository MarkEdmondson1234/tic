---
title: "Build lifecycle"
author: "Patrick Schratz, Kirill Müller"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Stages

CI services run builds in stages.
Stages are ordered as follows:

```{r, echo = FALSE, fig.align='center', dpi = 50}
knitr::include_graphics("img/build-lifecycle.png")
```

The `after_xxx` stages are run conditionally, dependent on their super-class name.
For example stage `after_success` will only be run of if there was a successfull execution of the "script" stage, i.e. no error.
The `after_deploy` stage will only be run if there the `deploy` stage was run before.

`tic` also uses the stages approach and simply fowards all the commands that should be run in stage to the `tic.R` file where these will specified in an CI-agnostic way using R syntax.
The `.travis.yml` file is subsequently not meant to be edited anymore (at least not for the specification of the stages).


```yml
# DO NOT CHANGE THE CODE BELOW
before_install: R -q -e 'install.packages(c("remotes", "curl")); remotes::install_local(getwd()); tic::prepare_all_stages(); tic::before_install()'
install: R -q -e 'tic::install()'
after_install: R -q -e 'tic::after_install()'
before_script: R -q -e 'tic::before_script()'
script: R -q -e 'tic::script()'
after_success: R -q -e 'tic::after_success()'
after_failure: R -q -e 'tic::after_failure()'
before_deploy: R -q -e 'tic::before_deploy()'
deploy:
  provider: script
  script: R -q -e 'tic::deploy()'
  on:
    all_branches: true
after_deploy: R -q -e 'tic::after_deploy()'
after_script: R -q -e 'tic::after_script()'
# DO NOT CHANGE THE CODE ABOVE
```

In a nutshell, the workflow is as follows:

`.travis.yml`/`appveyor.yml` -> `tic.R` -> commands/step to execute

An important point to note: The R code declared in `tic.R` is not meant to be run manually.
It also does not trigger a CI build.
All commands just define the workflow of the CI build.
For testing purposes, all stages and steps defined in `tic.R` can be executed by emulating a CI build locally using `tic()`.
See [Troubleshooting: Running tic locally](advanced#troubleshooting-running-tic-locally) for more information.

### Accessing a single stage

Which steps are executed in each stage is specified in `tic.R`.
A stage is executed by calling the respective `tic` function; for example for stage "deploy" `tic::deploy()`.
This function then sources `tic.R` and searches for a call to `get_stage(<stage name>)`.
For the "deploy" stage a search for `get_stage("deploy")` would be triggered.
If this call was found, all subsequent steps declared in this stage will get executed.
Again, remember that the order of the calls is fixed (see [here](build-lifecyle.html#stages)) and it does not matter in which order you declare the stages in `tic.R`.

Usually, steps are appended to stages using the pipe operator:

```r
get_stage("deploy") %>%
  add_step(step_build_pkgdown())
```

### Details of stages

#### before_install & install

An important stage for `tic` is the `before_install` stage.
Here, `tic` gets installed and runs `prepare_all_stages()`.
This function ensures that all subsequent steps can be executed by installing the required R packages.

Essentially it calls the `prepare()` function of all steps that were declared in `tic.R`.
For example, the `prepare()` function of the `step_rcmdcheck()` step makes sure that all dependencies of an R package get installed by calling `remotes::install_deps()` in the background.

All packages that should be stored in the "cache" of the CI service (so that they do not need to be installed again on every CI build) need to be installed in these stages.

#### script

The script stage is responsible to execute the important tasks of the CI run: For a package, it runs `R CMD check`, for a blogdown site it builds the site, etc..
In this stage all dependencies should be installed for a successful run.

#### deploy

This stage initiates the deployment (setting up SSH keys) and executes it.
If you want to automatically build a `pkgdown` site, you can do it here.
See [the vignette about deployment](deployment.html) for more information.

## Steps

Steps are the commands that are executed in each stage.
`tic` uses the pipe operator to chain steps in `tic.R`, for example

```r
get_stage("deploy") %>%
  add_step(step_build_pkgdown())
```

`step_build_pkgdown()` here is chained to stage "deploy" and subsequently only run in this stage.
More steps that should be run in this stage could just by piped after the `add_step(step_build_pkgdown())` step.
Steps are usually defined using two nested commands: `add_step()` and the corrsponding step, here `step_build_pkgdown()`.

We grouped the steps defined by the `tic` package in the following.
Please see the respective help pages of the functions for a more detailed documentation.

#### Basic

- `step_hello_world()`: print "Hello, World!" to the console, helps testing a tic setup
- `step_run_code()`: run arbitrary code, optionally run preparatory code and install dependent packages
    - `add_step(step_run_code())` can be abbreviated with `add_code_step()`
- `step_write_text_file()`: Creates a text file with arbitrary contents
    
#### Installation

- `step_install_cran()`: Installs one package from CRAN via `install.packages()`, but only if it's not already installed.
- `step_install_github()`: Installs one or more packages from GitHub via `remotes::install_github()`

#### R package specific

- `step_build_pkgdown()`: building package documentation via [pkgdown](https://github.com/r-lib/pkgdown)
- `step_rcmdcheck()`: run `R CMD check` via the _rcmdcheck_ package
    
##### Deployment

- `step_install_ssh_key()`: make available a private SSH key (which has been added before to your project by [`usethis`](https://github.com/r-lib/usethis)`::use_travis_deploy()`)
- `step_test_ssh()`: test the SSH connection to GitHub, helps troubleshooting deploy problems
- `step_setup_ssh()`: Adds to known hosts, installs private key, and tests the connection
- `step_setup_push_deploy()`: Clones a repo, inits author information, and sets up remotes for a subsequent `step_do_push_deploy()`
- `step_push_deploy()`: deploy to GitHub, with arguments:
    - `path`: which path to deploy, default: `"."`
    - `branch`: which branch to deploy to, default: `ci()$get_branch()`
    - `orphan`: should the branch consist of a single commit that contains all changes (`TRUE`), or should it be updated incrementally (`FALSE`, default)
        - You must specify a `branch` if you set `orphan = TRUE`
    - `remote_url`: the remote URL to push to, default: the URL related to the Travis run
    - `commit_message`: the commit message, will by default contain `[ci skip]` to avoid a loop, and useful information related to the CI run
    - `commit_paths`: Which path(s) to commit. Useful to only commit single files that have changed during the CI run.
    
### Macros

Macros in `tic` are combinations of steps for reoccuring workflows to keep `tic.R` tidy.
The macro function `add_package_checks()` comes with the most important steps that are needed for R package checking. 
It adds the following steps:

1. `step_rcmdcheck()` in the "script" stage, using the `warnings_are_errors`, `notes_are_errors` and `args` arguments.

2. A call to `covr::codecov()` in the "after_success" stage.

If you specify these stages on your own in `tic.R` while `add_package_checks()` is still present, the steps will be executed twice. 

Macros do not need to include steps across stages, they can also just cover a sequence of steps of a single stage.

Currently, `add_package_checks()` is the only macro implemented. 
We will add more macros in the future.
If you have a good usecase for a macro, let us know by opening an [issue](https://github.com/ropenscilabs/tic/issues).
