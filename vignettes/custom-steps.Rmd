---
title: "Developer info: Writing custom steps"
author: "Kirill MÃ¼ller"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom steps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

Many important steps running on CI systems are [already implemented](tic.html#steps) into *tic*.
The following vignette shows how new steps can be created and how *tic* defines them.
Internally, all steps are defined as [R6](https://github.com/wch/R6) classes.
A step is an environment-like (or list-like) object with named members `check`, `prepare`, and `run`.
These members should be functions that are callable without arguments.

The base class of a step that is `TicStep`.
All steps defined by tic, including the example `HelloWorld` step, use `TicStep` as the base class.
See [`steps-base.R`](https://github.com/ropenscilabs/tic/blob/master/R/steps-base.R) for the implementation.
The `step_...` functions in tic are simply the `new()` methods of the corresponding R6 class objects.
We recommend following the same pattern for your custom steps.

There should be no need to write steps on your own. 
However, if you have the need for a repeated use of specific combinations of `add_code_step()`, please let us know so in the repo by opening an [issue](https://github.com/ropenscilabs/tic/issues) so that we can discuss whether it makes sense to implement it as a custom step.

In the following, we describe the three methods which the new step class must override:

### `prepare()`

This method will be called by `prepare_all_stages()`.
It is intended to run in the `before_script` phase of the CI run.
You should install all dependent packages here that the step requires, which then can be cached by the CI system.
You also may include further preparation code here.
For example `step_rcmdcheck` verifies that the R packages `rcmdcheck` and `remotes` are installed:

```{r}
prepare = function() {
  verify_install(c("remotes", "rcmdcheck"))
  
  f_install_deps <- remotes::install_deps
  withr::with_libpaths(
    private$lib, action = "replace",
    {
      f_install_deps(dependencies = TRUE)
      utils::update.packages(ask = FALSE)
    }
  )
}
```

### `run()`

This method holds the commands that execute the essential calls in the end.
It is called when a new element of that step class is created, e.g. `RCMDcheck$new`.
For example, the `run()` function of class `RCMDcheck` looks as follows:

```{r}
run = function() {
res <- rcmdcheck::rcmdcheck(args = private$args)
  print(res)
  if (length(res$errors) > 0) {
    stopc("Errors found.")
  }
  if (private$warnings_are_errors && length(res$warnings) > 0) {
    stopc("Warnings found, and warnings_are_errors is set.")
  }
  if (private$notes_are_errors && length(res$notes) > 0) {
    stopc("Notes found, and notes_are_errors is set.")
 }
}
```

You can take a look at [this PR](https://github.com/ropenscilabs/tic/pull/75/files) to see how a new step implementation can look like.

The most minimalist version is the "Hello World" [example step](https://github.com/ropenscilabs/tic/blob/master/R/steps-base.R).
This new class only contains a `run()` function which does nothing more than printing "Hello World" to the console.
It is initialized by calling `step_hello_world()` which creates a new instances of this class.

```{r}
HelloWorld <- R6Class(
  "HelloWorld", inherit = TicStep,

  public = list(
    run = function() {
      print("Hello, world!")
    }
  )
)

#' Step: Hello, world!
#'
#' The simplest step possible: prints "Hello, world!" to the console when run, does not require
#' any preparation.
#' This step may be useful to test a \pkg{tic} setup or as a starting point when implementing a
#' custom step.
#'
#' @family steps
#' @export
step_hello_world <- function() {
  HelloWorld$new()
}
```

# Further information on the R6 class system

If you are unfamiliar with `R6` classes, here is a short guidance how the arguments are passed onto each function:
Consider the `step_rcmdcheck()` function ([link to source](https://github.com/ropenscilabs/tic/blob/master/R/steps-rcmdcheck.R)):

```{r}
step_rcmdcheck <- function(warnings_are_errors = TRUE, notes_are_errors = FALSE,
                           args = c("--no-manual", "--as-cran"),
                           build_args = "--force") {
  RCMDcheck$new(
    warnings_are_errors = warnings_are_errors,
    notes_are_errors = notes_are_errors,
    args = args,
    build_args = build_args
  )
}
```

Here, a new instance of the defined `R6` class `RCMDcheck` is initiated with `RCMDcheck$new()`.
The arguments to `step_rcmdcheck()` are passed on to the `initialize()` function of the `R6` class.
Here, the arguments are assigned to the "private" objects (e.g. `private$args`).
Next, the private objects are used in the `run()` function which does the actual work in the end.
You can read more about `R6` in Hadley's [book](https://adv-r.hadley.nz/r6.html).
